/* Copyright (C) 2017 Red Hat, Inc.
   This file is part of the Infinity Note Execution Library.

   The Infinity Note Execution Library is free software; you can
   redistribute it and/or modify it under the terms of the GNU Lesser
   General Public License as published by the Free Software
   Foundation; either version 2.1 of the License, or (at your option)
   any later version.

   The Infinity Note Execution Library is distributed in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the
   implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.  See the GNU Lesser General Public License for more
   details.

   You should have received a copy of the GNU Lesser General Public
   License along with the Infinity Note Execution Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <py3c.h>
#include <libi8x.h>
#include <syslog.h>

/* Utilities.  */

#define PY8X_MAX(a, b) ((a) > (b) ? (a) : (b))

#define PY8X_STRINGIZE(x) PY8X_STRINGIZE_1(x)
#define PY8X_STRINGIZE_1(x) #x

#define py8x_not_implemented()						\
  do {									\
    PyErr_SetString (PyExc_NotImplementedError,				\
		     __FILE__ ":" PY8X_STRINGIZE (__LINE__));		\
    return NULL;							\
  } while (0)

#define py8x_internal_error(msg)					\
  do {									\
    Py_FatalError ("py8x: " __FILE__ ":" PY8X_STRINGIZE (__LINE__)	\
		   ": internal error: "	 msg);				\
  } while (0);

#define py8x_logf_cond(ctx, priority, arg...)				\
  do {									\
    struct i8x_ctx *__ctx = (ctx);					\
									\
    if (i8x_ctx_get_log_priority (__ctx) >= priority)			\
      py8x_logf (__ctx, priority, __FILE__, __LINE__,			\
		 __FUNCTION__, ## arg);					\
  } while (0)

#define dbg(ctx, arg...) py8x_logf_cond (ctx, LOG_DEBUG, ## arg)
#define info(ctx, arg...) py8x_logf_cond (ctx, LOG_INFO, ## arg)

/* Forward declarations.  */

static void py8x_logf (struct i8x_ctx *ctx, int priority,
		       const char *filename, int linenumber,
		       const char *function, const char *format, ...)
  __attribute__ ((format(printf, 6, 7)));

static PyObject *py8x_ob_get_object_factory (struct i8x_object *ob);

/* Exceptions.  */

static PyObject *py8x_I8XError;

#define PY8X_RAISE(msg)							\
  do {									\
    PyErr_SetString (py8x_I8XError, msg);				\
    return NULL;							\
  } while (0)

#define PY8X_CHECK_CALL(ctx, err)					\
  do {									\
    if (err == I8X_ENOMEM)						\
      return PyErr_NoMemory ();						\
    else if ((err == I8X_NATCALL_FAILED					\
	      || err == I8X_READ_MEM_FAILED				\
	      || err == I8X_RELOC_FAILED)				\
	     && PyErr_Occurred () != NULL)				\
      return NULL; /* User code raised an exception.  */		\
    else if (err != I8X_OK)						\
      {									\
        char buf[1024];							\
	PY8X_RAISE (i8x_ctx_strerror_r (ctx, err, buf,  sizeof (buf)));	\
      }									\
  } while (0)

/* Attribute name under which py8x_encapsulate* stores libi8x
   object PyCapsules in the Python wrapper objects it creates.  */

#define PY8X_CNAME_ATTR "__py8x_private"

/* Helpers for each libi8x object.  */

#define PY8X_OBJECT_FUNCTIONS(TYPE, PREFIX)				\
  static inline struct i8x_ ## TYPE * __attribute__ ((always_inline))	\
  py8x_ ## PREFIX ## _from_capsule (PyObject *wrapped)			\
  {									\
    PyObject *c = PyObject_GetAttrString (wrapped, PY8X_CNAME_ATTR);	\
    if (c == NULL)							\
      return NULL;							\
    void *result = PyCapsule_GetPointer (c, NULL);			\
    Py_DECREF (c);							\
    return (struct i8x_ ## TYPE *) result;				\
  }
#pragma libi8x_api_object_functions

#define PY8X_FROM_CAPSULE_2(TYPE, NAME)					\
  py8x_ ## TYPE ## _from_capsule (NAME ## c);				\
  if (NAME == NULL)							\
    return NULL

#define PY8X_FROM_CAPSULE(TYPENAME)					\
  PY8X_FROM_CAPSULE_2 (TYPENAME, TYPENAME)

/* Userdata for all libi8x objects we create.  May be extended.
   Every libi8x object we pass into Python-space has one of these.
   It can be supplied to py8x_encapsulate* by the object's creator
   (if the object requires extended userdata).  If not supplied a
   generic userdata will be created.  It has two functions:

    1) It contains a regular reference to the parent object's
       Python wrapper.  This ensures parent objects remain live
       while live Python references to their children exist.
       (Python-side references are all child-parent).

    2) It contains a weak reference to this object's Python
       wrapper.  This interning means that Python objects can
       be compared using "is".  */

struct py8x_userdata;

struct py8x_userdata_ops
{
  const char *name;
  size_t size;
  void (*cleanup) (struct py8x_userdata *ud);
};

struct py8x_userdata
{
  const struct py8x_userdata_ops *ops;

  /* PyCapsule of parent object (referenced by us).
     NULL for i8x_ctx objects.  */
  PyObject *parent;

  /* PyWeakref of our own wrapped PyCapsule.  */
  PyObject *selfwr;
};

#define PY8X_USERDATA_FIELDS struct py8x_userdata _oud

/* Generic userdata ops for nonspecialized objects.  */

static const struct py8x_userdata_ops py8x_ob_udops =
  {
    "i8x_object",
    sizeof (struct py8x_userdata),
  };

/* Allocate and initialize a new py8x_userdata.  */

static struct py8x_userdata *
py8x_userdata_new (const struct py8x_userdata_ops *ops)
{
  struct py8x_userdata *ud;

  ud = calloc (1, ops->size);
  if (ud != NULL)
    ud->ops = ops;

  return ud;
}

/* Userdata cleanup for all objects.  */

static void
py8x_userdata_free (void *ud_p)
{
  struct py8x_userdata *ud = (struct py8x_userdata *) ud_p;

  if (ud->ops->cleanup != NULL)
    ud->ops->cleanup (ud);

  Py_XDECREF (ud->parent);
  Py_XDECREF (ud->selfwr);

  free (ud);
}

/* Get an object's userdata.  */

#define py8x_get_userdata(o)						\
  ((struct py8x_userdata *)						\
     i8x_ob_get_userdata ((struct i8x_object *) (o)))

/* PyCapsule_Destructor suitable for all libi8x objects.  */

static void
py8x_ob_unref (PyObject *obc)
{
  struct i8x_object *ob = PyCapsule_GetPointer (obc, NULL);
  dbg (i8x_ob_get_ctx (ob), "%s %p capsule released\n",
       i8x_ob_get_classname (ob), ob);

  struct py8x_userdata *ud = py8x_get_userdata (ob);
  if (ud == NULL)
    py8x_internal_error ("object userdata == NULL");

  /* Release the child before the parent.  */
  PyObject *parent = ud->parent;
  ud->parent = NULL;

  i8x_ob_unref (ob);
  Py_XDECREF (parent);
}

/* Encapsulate and return a libi8x object.  */

static PyObject *
py8x_encapsulate_2 (struct i8x_object *ob, struct py8x_userdata *new_ud)
{
  struct py8x_userdata *ud;
  PyObject *result = NULL;

  /* Encapsulate NULLs as Py_None.  */
  if (ob == NULL)
    {
      if (new_ud != NULL)
	{
	  /* The caller supplied userdata for a NULL object.  */
	  PyErr_SetString (PyExc_AssertionError,
			   "ob == NULL && new_ud != NULL");
	  return NULL;
	}

      Py_RETURN_NONE;
    }

  ud = py8x_get_userdata (ob);
  if (ud != NULL && new_ud != NULL)
    {
      /* The caller supplied userdata for an object that already has
	 userdata set.  This is a programmer error.  */
      PyErr_SetString (PyExc_AssertionError,
		       "ud != NULL && new_ud != NULL");
      return NULL;
    }

  if (ud == NULL)
    {
      /* The object has no userdata. Create if necessary.  */
      if (new_ud == NULL)
	new_ud = py8x_userdata_new (&py8x_ob_udops);
      if (new_ud == NULL)
	return PyErr_NoMemory ();

      /* Attach it to the object. */
      i8x_ob_set_userdata (ob, new_ud, py8x_userdata_free);

      ud = new_ud;
    }

  /* Reference the object's parent's wrapper.  */
  if (new_ud != NULL && ud->parent == NULL)
    {
      struct i8x_object *parent = i8x_ob_get_parent (ob);

      if (parent != NULL)
	{
	  ud->parent = py8x_encapsulate_2 (parent, NULL);
	  if (ud->parent == NULL)
	    return NULL;
	}
    }

  /* Try and use a previously-created wrapped capsule.  */
  if (ud->selfwr != NULL)
    {
      result = PyWeakref_GetObject (ud->selfwr);
      if (result == NULL)
	return NULL;

      if (result == Py_None)
	{
	  result = NULL;

	  Py_DECREF (ud->selfwr);
	  ud->selfwr = NULL;
	}
      else
	Py_INCREF (result);
    }

  /* Create a new wrapped capsule if necessary.  */
  if (result == NULL)
    {
      PyObject *capsule;

      /* Create a capsule to hold the object.  */
      capsule = PyCapsule_New (i8x_ob_ref (ob), NULL, py8x_ob_unref);
      if (capsule == NULL)
	return NULL;

      const char *classname = i8x_ob_get_classname (ob);
      dbg (i8x_ob_get_ctx (ob), "%s %p encapsulated\n",
	   classname, ob);

      /* Create a Python object to hold the capsule.  */
      result = PyObject_CallFunction (py8x_ob_get_object_factory (ob),
				      "s", classname);
      if (result == NULL)
	{
	  Py_DECREF (capsule);
	  return NULL;
	}

      /* Store the capsule in the wrapper object.  */
      int err = PyObject_SetAttrString (result, PY8X_CNAME_ATTR, capsule);
      Py_DECREF (capsule);
      if (err != 0)
	{
	  Py_DECREF (result);
	  return NULL;
	}

      /* Store a weak reference to our own wrapper object.  */
      ud->selfwr = PyWeakref_NewRef (result, NULL);
      if (ud->selfwr == NULL)
	{
	  Py_DECREF (result);
	  return NULL;
	}
    }

  return result;
}

static PyObject *
py8x_encapsulate_1 (struct i8x_object *ob, struct py8x_userdata *ud)
{
  PyObject *result = py8x_encapsulate_2 (ob, ud);

  i8x_ob_unref (ob);

  return result;
}

#define py8x_encapsulate(x)						\
  (py8x_encapsulate_1 ((struct i8x_object *) x, NULL))

/* Helpers for objects with extended userdata.  */

#define PY8X_USERDATA_FUNCTIONS(TYPE)					\
  static inline struct py8x_ ## TYPE ## _userdata *			\
    __attribute__ ((always_inline))					\
  py8x_ ## TYPE ## _userdata_new (void)					\
  {									\
    return (struct py8x_ ## TYPE ## _userdata *)			\
      py8x_userdata_new (&py8x_ ## TYPE ## _udops);			\
  }									\
									\
  static inline struct py8x_ ## TYPE ## _userdata *			\
    __attribute__ ((always_inline))					\
  py8x_ ## TYPE ## _get_userdata (struct i8x_ ## TYPE *x)		\
  {									\
    return (struct py8x_ ## TYPE ## _userdata *)			\
      i8x_ ## TYPE ## _get_userdata (x);				\
  }									\
									\
  static inline PyObject * __attribute__ ((always_inline))		\
  py8x_ ## TYPE ## _encapsulate (struct i8x_ ## TYPE *x,		\
				 struct py8x_ ## TYPE ## _userdata *ud) \
  {									\
    return py8x_encapsulate_1 ((struct i8x_object *) x,			\
			       (struct py8x_userdata *) ud);		\
  }

/* Context (i8x_ctx) userdata.  */

struct py8x_ctx_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Object factory.  A Python callable invoked to create
     weak-referencable wrapper objects into which we store
     PyCapsule-wrapped libi8x objects.  */
  PyObject *obf_fn;

  /* Logging function.  May be Py_None, in which case
     messages will be output on stderr.  */
  PyObject *log_fn;
};

static void
py8x_ctx_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_ctx_userdata *ud = (struct py8x_ctx_userdata *) ud_p;

  Py_DECREF (ud->obf_fn);
  Py_DECREF (ud->log_fn);
}

static const struct py8x_userdata_ops py8x_ctx_udops =
  {
    "i8x_ctx",
    sizeof (struct py8x_ctx_userdata),
    py8x_ctx_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (ctx)

/* Userdata for the context currently being created by py8x_ctx_new.
   Various things can log before py8x_ctx_encapsulate sets the
   context's userdata; this static global exists so that py8x_log
   can access the Python log function it needs in this case.  */

static struct py8x_ctx_userdata *py8x_new_context_ud;

/* Log a message to stderr.  Should mirror libi8x's default logger.  */

static void
py8x_log_stderr (int priority, const char *filename, int linenumber,
		 const char *function, const char *msg)
{
  /* PySys_WriteStderr wants 1000 bytes max.  */
  char buf[1000];
  ssize_t size = sizeof (buf);
  const char *dots = "...\n";

  if (snprintf (buf, size, "py8x: %s: %s", function, msg) ==  size)
    strcpy (buf + size - sizeof (dots), dots);

  PySys_WriteStderr ("%s", buf);
}

/* Log a message, ideally via the user-supplied logging function.  */

static void
py8x_log (struct i8x_ctx *ctx, int priority, const char *filename,
	  int linenumber, const char *function, const char *msg)
{
  struct py8x_ctx_userdata *ud = py8x_ctx_get_userdata (ctx);
  PyObject *result = NULL;

  /* No userdata means we're within py8x_ctx_new, before
     py8x_ctx_encapsulate has had chance to set it.  */
  if (ud == NULL)
    ud = py8x_new_context_ud;
  if (ud == NULL)
    {
      py8x_log_stderr (priority, filename, linenumber, function, msg);
      py8x_internal_error ("context userdata == NULL");
    }

  /* Call the user-defined logging function if there is one.  */
  if (ud->log_fn != Py_None)
    {
      result = PyObject_CallFunction (ud->log_fn, "isiss", priority,
				      filename, linenumber, function,
				      msg);

      /* Note that there's no way to signal an error to libi8x
	 in the event the logging function raises an exception,
	 so exceptions here may appear in place of others.  We
	 write what's happening to stderr to give some kind of
	 clue.  */

      if (result == NULL)
	{
	  PySys_WriteStderr ("py8x: user-defined logger failed with "
			     "the following exception:\n");
	  PyErr_PrintEx (0);
	  PySys_WriteStderr ("py8x: the message being logged was:\n");
	}
    }

  if (result == NULL)
    py8x_log_stderr (priority, filename, linenumber, function, msg);

  Py_XDECREF (result);
}

/* Logging function for all py8x-created contexts.  */

static void __attribute__ ((format(printf, 6, 0)))
py8x_vlogf (struct i8x_ctx *ctx, int priority, const char *filename,
	    int linenumber, const char *function, const char *format,
	    va_list args)
{
  char *msg;

  int count = vasprintf (&msg, format, args);
  if (count < 0)
    msg = "vasprintf failed\n";

  py8x_log (ctx, priority, filename, linenumber, function, msg);

  if (count >= 0)
    free (msg);
}

/* Logging function for py8x_logf_cond macros.  */

static void
py8x_logf (struct i8x_ctx *ctx, int priority, const char *filename,
	   int linenumber, const char *function, const char *format,
	   ...)
{
  va_list args;

  va_start (args, format);
  py8x_vlogf (ctx, priority, filename, linenumber, function, format,
	      args);
  va_end (args);
}

/* Python binding for i8x_ctx_new.  */

static PyObject *
py8x_ctx_new (PyObject *self, PyObject *args)
{
  PyObject *obf_fn;
  int flags;
  PyObject *log_fn;
  struct py8x_ctx_userdata *ud;
  struct i8x_ctx *ctx = NULL;
  i8x_err_e err;
  PyObject *result = NULL;

  if (!PyArg_ParseTuple (args, "OiO", &obf_fn, &flags, &log_fn))
    return NULL;

  ud = py8x_ctx_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  Py_INCREF (obf_fn);
  ud->obf_fn = obf_fn;

  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  py8x_new_context_ud = ud;
  err = i8x_ctx_new (flags, py8x_vlogf, &ctx);
  if (err == I8X_OK)
    result = py8x_ctx_encapsulate (ctx, ud);
  py8x_new_context_ud = NULL;

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (NULL, err);

  return result;
}

/* Return the object factory for an object.  */

static PyObject *
py8x_ob_get_object_factory (struct i8x_object *ob)
{
  return py8x_ctx_get_userdata (i8x_ob_get_ctx (ob))->obf_fn;
}

/* Python binding for i8x_ctx_set_log_fn.  */

static PyObject *
py8x_ctx_set_log_fn (PyObject *self, PyObject *args)
{
  PyObject *ctxc, *log_fn;

  if (!PyArg_ParseTuple (args, "OO", &ctxc, &log_fn))
    return NULL;

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct py8x_ctx_userdata *ud = py8x_ctx_get_userdata (ctx);

  Py_DECREF (ud->log_fn);
  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  Py_RETURN_NONE;
}

/* Function (i8x_func) userdata.  */

struct py8x_func_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Implementation (native only).  */
  PyObject *impl;
};

static void
py8x_func_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_func_userdata *ud = (struct py8x_func_userdata *) ud_p;

  Py_XDECREF (ud->impl);
}

static const struct py8x_userdata_ops py8x_func_udops =
  {
    "i8x_func",
    sizeof (struct py8x_func_userdata),
    py8x_func_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (func)

/* Actions for py8x_unpack_tuple.  */

typedef enum
{
  PY8X_ARGS,
  PY8X_RETS
}
py8x_argsrets_e;

/* Helper for py8x_{pack,unpack}_tuple.  */

#define py8x_pack_unpack_types(ref, what)				\
  (what == PY8X_ARGS							\
   ? i8x_funcref_get_ptypes (ref)					\
   : i8x_funcref_get_rtypes (ref))

/* Pack a Python tuple from an array of i8x_values.  */

static PyObject *
py8x_pack_tuple (union i8x_value *src, struct i8x_funcref *ref,
		 py8x_argsrets_e what)
{
  struct i8x_list *types =  py8x_pack_unpack_types (ref, what);
  size_t length = i8x_list_size (types);
  size_t offset = what == PY8X_ARGS ? 3 : 0;
  struct i8x_listitem *li;
  size_t i;

  PyObject *result = PyTuple_New (length + offset);
  if (result == NULL)
    return NULL;

  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      int index = what == PY8X_ARGS ? i + offset : length - i - 1;
      PyObject *item;

      if (i8x_type_is_functype (type))
	item = py8x_encapsulate (i8x_funcref_ref (src[i].f));
      else
	item = PyLong_FromUnsignedLong (src[i].u);

      if (item == NULL || PyTuple_SetItem (result, index, item) != 0)
	{
	  Py_DECREF (result);
	  return NULL;
	}
    }

  return result;
}

/* Unpack a Python tuple into an array of i8x_values.  */

static bool
py8x_unpack_tuple (union i8x_value *dst, PyObject *src,
		   struct i8x_funcref *ref, py8x_argsrets_e what)
{
  struct i8x_list *types =  py8x_pack_unpack_types (ref, what);
  size_t length = i8x_list_size (types);
  struct i8x_listitem *li;
  size_t i;

  if (PySequence_Length (src) != (Py_ssize_t) length)
    {
      PyErr_SetString (py8x_I8XError,
		       what == PY8X_ARGS
		       ? "wrong number of arguments"
		       : "wrong number of returns");
      return false;
    }

  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      int index = what == PY8X_ARGS ? i : length - i - 1;
      PyObject *item = PySequence_GetItem (src, index);

      if (item == NULL)
	return false;

      if (i8x_type_is_functype (type))
	{
	  struct i8x_funcref *value = py8x_funcref_from_capsule (item);

	  Py_DECREF (item);
	  if (value == NULL)
	    return false;

	  dst[i].f = value;
	}
      else
	{
	  long value = PyLong_AsLong (item);

	  Py_DECREF (item);
	  if (value == -1 && PyErr_Occurred () != NULL)
	    return false;

	  dst[i].i = value;
	}
    }

  return true;
}

#define py8x_pack_args(src, ref) 					\
  py8x_pack_tuple (src, ref, PY8X_ARGS)

#define py8x_pack_rets(src, ref) 					\
  py8x_pack_tuple (src, ref, PY8X_RETS)

#define py8x_unpack_args(dst, src, ref) 				\
  py8x_unpack_tuple (dst, src, ref, PY8X_ARGS)

#define py8x_unpack_rets(dst, src, ref) 				\
  py8x_unpack_tuple (dst, src, ref, PY8X_RETS)

/* Helper for py8x_natfunc_impl.  */

#define PY8X_NFI_SETARG(i, v)						\
  do {									\
    PyObject *arg = v;							\
									\
    if (arg == NULL || PyTuple_SetItem (args, (i), arg) != 0)		\
      {									\
	Py_DECREF (args);						\
	return I8X_NATCALL_FAILED;					\
      }									\
  } while (0)

/* Implementation function for all py8x-created native functions.  */

static i8x_err_e
py8x_natfunc_impl (struct i8x_xctx *xctx,
		   struct i8x_inf *inf,
		   struct i8x_func *func,
		   union i8x_value *argv,
		   union i8x_value *retv)
{
  struct i8x_funcref *ref = i8x_func_get_funcref (func);

  /* Pack the arguments.  */
  PyObject *args = py8x_pack_args (argv, ref);

  if (args == NULL)
    return I8X_NATCALL_FAILED;

  PY8X_NFI_SETARG (0, py8x_encapsulate (i8x_xctx_ref (xctx)));
  PY8X_NFI_SETARG (1, py8x_encapsulate (i8x_inf_ref (inf)));
  PY8X_NFI_SETARG (2, py8x_encapsulate (i8x_func_ref (func)));

  /* Make the call.  */
  struct py8x_func_userdata *ud = py8x_func_get_userdata (func);

  PyObject *rets = PyObject_Call (ud->impl, args, NULL);
  Py_DECREF (args);
  if (rets == NULL)
    return I8X_NATCALL_FAILED;

  /* Unpack the returns.  */
  bool success = py8x_unpack_rets (retv, rets, ref);
  Py_DECREF (rets);
  return success ? I8X_OK : I8X_NATCALL_FAILED;
}

/* Python binding for i8x_ctx_import_bytecode.  */

static PyObject *
py8x_ctx_import_bytecode (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  Py_buffer buffer;
  const char *srcname;
  long srcoff;

  if (!PyArg_ParseTuple (args, "O"
#if IS_PY3
			 "y"
#else
			 "s"
#endif /* IS_PY3 */
			 "*zl", &ctxc, &buffer, &srcname, &srcoff))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_bytecode (ctx,
					   buffer.buf, buffer.len,
					   srcname, srcoff,
					   &func);
  PyBuffer_Release (&buffer);

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return py8x_func_encapsulate (func, ud);
}

/* Python binding for i8x_ctx_import_native.  */

static PyObject *
py8x_ctx_import_native (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  const char *provider, *name, *ptypes, *rtypes;
  PyObject *impl;

  if (!PyArg_ParseTuple (args, "OssssO", &ctxc,
			 &provider, &name, &ptypes, &rtypes, &impl))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  Py_INCREF (impl);
  ud->impl = impl;

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_native (ctx,
					 provider, name, ptypes, rtypes,
					 py8x_natfunc_impl, &func);
  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return py8x_func_encapsulate (func, ud);
}

/* Python binding for i8x_xctx_call.  */

static PyObject *
py8x_xctx_call (PyObject *self, PyObject *args)
{
  PyObject *xctxc, *refc, *infc, *tmp;

  if (!PyArg_ParseTuple (args, "OOOO", &xctxc, &refc, &infc, &tmp))
    return NULL;
  args = tmp;

  struct i8x_funcref *ref = PY8X_FROM_CAPSULE_2 (funcref, ref);
  size_t argc = i8x_funcref_get_num_params (ref);
  size_t retc = i8x_funcref_get_num_returns (ref);
  union i8x_value *argv = alloca (PY8X_MAX (argc, retc));
  union i8x_value *retv = argv;

  if (!py8x_unpack_args (argv, args, ref))
    return NULL;

  struct i8x_xctx *xctx = PY8X_FROM_CAPSULE (xctx);
  struct i8x_inf *inf = PY8X_FROM_CAPSULE (inf);
  struct i8x_ctx *ctx = i8x_xctx_get_ctx (xctx);
  i8x_err_e err = i8x_xctx_call (xctx, ref, inf, argv, retv);

  PY8X_CHECK_CALL (ctx, err);

  return py8x_pack_rets (retv, ref);
}

/* Inferior (i8x_inf) userdata.  */

struct py8x_inf_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Memory reader function.  */
  PyObject *read_mem_fn;

  /* Relocation function.  */
  PyObject *relocate_fn;
};

static void
py8x_inf_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_inf_userdata *ud = (struct py8x_inf_userdata *) ud_p;

  Py_XDECREF (ud->read_mem_fn);
  Py_XDECREF (ud->relocate_fn);
}

static const struct py8x_userdata_ops py8x_inf_udops =
  {
    "i8x_inf",
    sizeof (struct py8x_inf_userdata),
    py8x_inf_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (inf)

/* Helpers for py8x_read_mem_fn and py8x_relocate_fn.  */

#define PY8X_RxF_SETARG(i, v, e)					\
  do {									\
    PyObject *arg = v;							\
									\
    if (arg == NULL || PyTuple_SetItem (args, (i), arg) != 0)		\
      {									\
	Py_DECREF (args);						\
	return e;							\
      }									\
  } while (0)

#define PY8X_RMF_SETARG(i, v) PY8X_RxF_SETARG(i, v, I8X_READ_MEM_FAILED)
#define PY8X_RLF_SETARG(i, v) PY8X_RxF_SETARG(i, v, I8X_RELOC_FAILED)

/* Memory reader function for all py8x-created inferiors.  */

static i8x_err_e
py8x_read_mem_fn (struct i8x_inf *inf, uintptr_t addr, size_t len,
		  void *result)
{
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  if (ud->read_mem_fn == NULL || ud->read_mem_fn == Py_None)
    {
      PyErr_SetString (py8x_I8XError,
		       "inferior has no read_mem function");
      return I8X_READ_MEM_FAILED;
    }

  /* Pack the arguments.  */
  PyObject *args = PyTuple_New (3);
  if (args == NULL)
    return I8X_READ_MEM_FAILED;

  PY8X_RMF_SETARG (0, py8x_encapsulate (i8x_inf_ref (inf)));
  PY8X_RMF_SETARG (1, PyLong_FromUnsignedLong (addr));
  PY8X_RMF_SETARG (2, PyLong_FromSize_t (len));

  /* Make the call.  */
  PyObject *ret = PyObject_Call (ud->read_mem_fn, args, NULL);
  Py_DECREF (args);
  if (ret == NULL)
    return I8X_READ_MEM_FAILED;

  /* Read out the result.  */
  Py_buffer buf;

  if (PyObject_GetBuffer (ret, &buf, PyBUF_SIMPLE) != 0)
    {
      Py_DECREF (ret);
      return I8X_READ_MEM_FAILED;
    }

  if (buf.len != (Py_ssize_t) len)
    {
      Py_DECREF (ret);
      PyErr_SetString (py8x_I8XError,
		       "read_mem_fn returned bad length");
      return I8X_READ_MEM_FAILED;
    }

  memcpy (result, buf.buf, len);
  return I8X_OK;
}

/* Relocation function for all py8x-created inferiors.  */

static i8x_err_e
py8x_relocate_fn (struct i8x_inf *inf, struct i8x_reloc *reloc,
		  uintptr_t *result)
{
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  if (ud->relocate_fn == NULL || ud->relocate_fn == Py_None)
    {
      PyErr_SetString (py8x_I8XError,
		       "inferior has no relocate function");
      return I8X_RELOC_FAILED;
    }

  /* Pack the arguments.  */
  PyObject *args = PyTuple_New (2);
  if (args == NULL)
    return I8X_RELOC_FAILED;

  PY8X_RLF_SETARG (0, py8x_encapsulate (i8x_inf_ref (inf)));
  PY8X_RLF_SETARG (1, py8x_encapsulate (i8x_reloc_ref (reloc)));

  /* Make the call.  */
  PyObject *ret = PyObject_Call (ud->relocate_fn, args, NULL);
  Py_DECREF (args);
  if (ret == NULL)
    return I8X_RELOC_FAILED;

  /* Read out the result.  */
  uintptr_t res = PyLong_AsUnsignedLong (ret);
  if (PyErr_Occurred () != NULL)
    return I8X_RELOC_FAILED;

  *result = res;
  return I8X_OK;
}

/* Python binding for i8x_inf_new.  */

static PyObject *
py8x_inf_new (PyObject *self, PyObject *args)
{
  PyObject *ctxc;

  if (!PyArg_ParseTuple (args, "O", &ctxc))
    return NULL;

  struct py8x_inf_userdata *ud = py8x_inf_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_inf *inf;
  i8x_err_e err = i8x_inf_new (ctx, &inf);

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  i8x_inf_set_read_mem_fn (inf, py8x_read_mem_fn);
  i8x_inf_set_relocate_fn (inf, py8x_relocate_fn);

  return py8x_inf_encapsulate (inf, ud);
}

/* Python binding for i8x_ctx_set_read_mem_fn.  */

static PyObject *
py8x_inf_set_read_mem_fn (PyObject *self, PyObject *args)
{
  PyObject *infc, *read_mem_fn;

  if (!PyArg_ParseTuple (args, "OO", &infc, &read_mem_fn))
    return NULL;

  struct i8x_inf *inf = PY8X_FROM_CAPSULE (inf);
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  Py_XDECREF (ud->read_mem_fn);
  Py_INCREF (read_mem_fn);
  ud->read_mem_fn = read_mem_fn;

  Py_RETURN_NONE;
}

/* Python binding for i8x_ctx_set_relocate_fn.  */

static PyObject *
py8x_inf_set_relocate_fn (PyObject *self, PyObject *args)
{
  PyObject *infc, *relocate_fn;

  if (!PyArg_ParseTuple (args, "OO", &infc, &relocate_fn))
    return NULL;

  struct i8x_inf *inf = PY8X_FROM_CAPSULE (inf);
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  Py_XDECREF (ud->relocate_fn);
  Py_INCREF (relocate_fn);
  ud->relocate_fn = relocate_fn;

  Py_RETURN_NONE;
}

/* Helper for methods that return list items (i8x_listitem).  */

#define PY8X_RETURN_LISTITEM(value)					\
  do {									\
    struct i8x_listitem *result = value;				\
									\
    if (result == NULL)							\
      {									\
	PyErr_SetNone(PyExc_StopIteration);				\
	return NULL;							\
      }									\
									\
    return py8x_encapsulate (i8x_listitem_ref (result));		\
  } while (0)

/* Python binding for i8x_list_get_first.  */

static PyObject *
py8x_list_get_first (PyObject *self, PyObject *args)
{
  PyObject *listc;

  if (!PyArg_ParseTuple (args, "O", &listc))
    return NULL;

  struct i8x_list *list = PY8X_FROM_CAPSULE (list);

  PY8X_RETURN_LISTITEM (i8x_list_get_first (list));
}

/* Python binding for i8x_list_get_next.  */

static PyObject *
py8x_list_get_next (PyObject *self, PyObject *args)
{
  PyObject *listc;
  PyObject *currc;

  if (!PyArg_ParseTuple (args, "OO", &listc, &currc))
    return NULL;

  struct i8x_list *list = PY8X_FROM_CAPSULE (list);
  struct i8x_listitem *curr = PY8X_FROM_CAPSULE_2 (listitem, curr);

  PY8X_RETURN_LISTITEM (i8x_list_get_next (list, curr));
}

/* Python binding for i8x_note_get_unique_chunk.  */

static PyObject *
py8x_note_get_unique_chunk (PyObject *self, PyObject *args)
{
  PyObject *notec;
  uintptr_t type_id;
  int must_exist;

  if (!PyArg_ParseTuple (args, "Oki", &notec, &type_id, &must_exist))
    return NULL;

  struct i8x_note *note = PY8X_FROM_CAPSULE (note);
  struct i8x_chunk *chunk;
  i8x_err_e err = i8x_note_get_unique_chunk (note, type_id, must_exist,
					     &chunk);

  PY8X_CHECK_CALL (i8x_note_get_ctx (note), err);

  return py8x_encapsulate (i8x_chunk_ref (chunk));
}

/* Python binding for i8x_chunk_get_encoded.  */

static PyObject *
py8x_chunk_get_encoded (PyObject *self, PyObject *args)
{
  PyObject *chunkc;

  if (!PyArg_ParseTuple (args, "O", &chunkc))
    return NULL;

  struct i8x_chunk *chunk = PY8X_FROM_CAPSULE (chunk);

  return PyBytes_FromStringAndSize (i8x_chunk_get_encoded (chunk),
				    i8x_chunk_get_encoded_size (chunk));
}

#pragma libi8x_api_functions

/* Convert an unsigned value to signed w.r.t. libi8x's wordsize.  */

static PyObject *
py8x_to_signed (PyObject *self, PyObject *args)
{
  PyObject *n;
  union i8x_value v;

  if (!PyArg_ParseTuple (args, "O", &n))
    return NULL;

  v.u = PyLong_AsUnsignedLong (n);
  if (PyErr_Occurred () != NULL)
    return NULL;

  return PyLong_FromLong (v.i);
}

/* Convert an signed value to unsigned w.r.t. libi8x's wordsize.  */

static PyObject *
py8x_to_unsigned (PyObject *self, PyObject *args)
{
  union i8x_value v;

  if (!PyArg_ParseTuple (args, "l", &v.i))
    return NULL;

  return PyLong_FromUnsignedLong (v.u);
}

/* Module-level functions table.  */

#define PY8X_FUNCTION(name) {#name, py8x_ ## name, METH_VARARGS, NULL}

static PyMethodDef libi8x_methods[] = {
  PY8X_FUNCTION (ctx_new),
  PY8X_FUNCTION (ctx_set_log_fn),
  PY8X_FUNCTION (ctx_import_bytecode),
  PY8X_FUNCTION (ctx_import_native),
  PY8X_FUNCTION (xctx_call),
  PY8X_FUNCTION (inf_new),
  PY8X_FUNCTION (inf_set_read_mem_fn),
  PY8X_FUNCTION (inf_set_relocate_fn),
  PY8X_FUNCTION (list_get_first),
  PY8X_FUNCTION (list_get_next),
  PY8X_FUNCTION (note_get_unique_chunk),
  PY8X_FUNCTION (chunk_get_encoded),
  PY8X_FUNCTION (to_signed),
  PY8X_FUNCTION (to_unsigned),
#pragma libi8x_api_function_table
  {NULL, NULL, 0, NULL}
};

/* Module definition.  */

static struct PyModuleDef libi8x_moduledef =
  {
    PyModuleDef_HEAD_INIT,
    .m_name = "_libi8x",
    .m_doc = PyDoc_STR ("Python bindings for libi8x."),
    .m_size = -1,
    .m_methods = libi8x_methods,
  };

/* Module initialization function.  */

MODULE_INIT_FUNC (_libi8x)
{
  PyObject *m = PyModule_Create (&libi8x_moduledef);
  if (m == NULL)
    return NULL;

  py8x_I8XError = PyErr_NewException ("_libi8x.I8XError",
				   PyExc_RuntimeError, NULL);
  if (py8x_I8XError == NULL)
    return NULL;

  if (PyModule_AddObject (m, "I8XError", py8x_I8XError) != 0)
    return NULL;

#pragma libi8x_api_constants

  return m;
}
