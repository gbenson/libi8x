/* Copyright (C) 2017 Red Hat, Inc.
   This file is part of the Infinity Note Execution Library.

   The Infinity Note Execution Library is free software; you can
   redistribute it and/or modify it under the terms of the GNU Lesser
   General Public License as published by the Free Software
   Foundation; either version 2.1 of the License, or (at your option)
   any later version.

   The Infinity Note Execution Library is distributed in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the
   implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.  See the GNU Lesser General Public License for more
   details.

   You should have received a copy of the GNU Lesser General Public
   License along with the Infinity Note Execution Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <py3c.h>
#include <libi8x.h>

#define PY8X_STRINGIZE(x) PY8X_STRINGIZE_1(x)
#define PY8X_STRINGIZE_1(x) #x

#define py8x_not_implemented()						\
  do {									\
    PyErr_SetString (PyExc_NotImplementedError,				\
		     __FILE__ ":" PY8X_STRINGIZE (__LINE__));		\
    return NULL;							\
  } while (0)

/* Turn libi8x errors into Python exceptions.  */

#define PY8X_CHECK_CALL(ctx, err)					\
  do {									\
    if (err == I8X_ENOMEM)						\
      return PyErr_NoMemory ();						\
    else if (err != I8X_OK)						\
      py8x_not_implemented ();						\
  } while (0)

/* Helpers for each libi8x object.  */

#define PY8X_OBJECT_FUNCTIONS(TYPE, PREFIX)				\
  static inline struct i8x_ ## TYPE * __attribute__ ((always_inline))	\
  py8x_ ## PREFIX ## _from_capsule (PyObject *c)			\
  {									\
    return (struct i8x_ ## TYPE *) PyCapsule_GetPointer (c, NULL);	\
  }
#pragma libi8x_api_object_functions

/* PyCapsule_Destructor suitable for all libi8x objects.  */

static void
py8x_ob_unref (PyObject *obc)
{
  i8x_ob_unref (py8x_ob_from_capsule (obc));
}

/* Context (i8x_ctx) userdata.  */

struct py8x_ctx_userdata
{
  /* Logging function.  */
  PyObject *log_fn;
};

/* Userdata cleanup for py8x_ctx_userdata.  */

static void
py8x_ctx_udcleanup (void *ud_p)
{
  struct py8x_ctx_userdata *ud = (struct py8x_ctx_userdata *) ud_p;

  Py_XDECREF (ud->log_fn);

  free (ud);
}

/* Userdata for the context currently being created by i8x_ctx_new.
   i8x_ctx_new can log before we have a chance to set the context's
   userdata; this static global exists so that py8x_log can access
   the Python log function it needs in this case.  */

static struct py8x_ctx_userdata *py8x_new_context_ud;

/* Logging function set for all i8x_ctx objects we create.  */

static void
py8x_log (struct i8x_ctx *ctx,
	  int pri, const char *file, int line, const char *fn,
	  const char *format, va_list args)
{
  struct py8x_ctx_userdata *ud =
    (struct py8x_ctx_userdata *) i8x_ctx_get_userdata (ctx);
  char *msg;
  int count;
  PyObject *arglist;
  PyObject *result;

  /* No userdata means we're in i8x_ctx_new, before
     py8x_ctx_new has had chance to set it.  */
  if (ud == NULL)
    ud = py8x_new_context_ud;
  if (ud == NULL)
    abort ();

  count = vasprintf (&msg, format, args);
  if (count < 0)
    msg = "vasprintf failed";

  if (ud->log_fn == Py_None)
    {
      /* PySys_WriteStderr wants 1000 bytes max.  */
      char buf[1000];

      snprintf (buf, sizeof (buf), "py8x: %s: %s", fn, msg);
      buf[sizeof (buf) - 1] = '\0';
      PySys_WriteStderr ("%s", buf);
    }
  else
    {
      arglist = Py_BuildValue ("isiss", pri, file, line, fn, msg);

      result = PyEval_CallObject (ud->log_fn, arglist);
      Py_DECREF (arglist);

      Py_DECREF (result);
    }

  if (count >= 0)
    free (msg);
}

/* Python binding for i8x_ctx_new.  */

static PyObject *
py8x_ctx_new (PyObject *self, PyObject *args)
{
  int flags;
  PyObject *log_fn;
  struct i8x_ctx *ctx = NULL;
  i8x_err_e err;

  if (!PyArg_ParseTuple (args, "iO", &flags, &log_fn))
    return NULL;

  py8x_new_context_ud = calloc (1, sizeof (struct py8x_ctx_userdata));
  if (py8x_new_context_ud == NULL)
    return PyErr_NoMemory ();

  Py_INCREF (log_fn);
  py8x_new_context_ud->log_fn = log_fn;

  err = i8x_ctx_new (flags, py8x_log, &ctx);

  if (err == I8X_OK)
    i8x_ctx_set_userdata (ctx, py8x_new_context_ud, py8x_ctx_udcleanup);
  else
    py8x_ctx_udcleanup (py8x_new_context_ud);

  py8x_new_context_ud = NULL;

  PY8X_CHECK_CALL (NULL, err);

  return PyCapsule_New (ctx, NULL, py8x_ob_unref);
}

/* Python binding for i8x_ctx_set_log_fn.  */

static PyObject *
py8x_ctx_set_log_fn (PyObject *self, PyObject *args)
{
  PyObject *ctxc, *log_fn;

  if (!PyArg_ParseTuple (args, "OO", &ctxc, &log_fn))
    return NULL;

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct py8x_ctx_userdata *ud =
    (struct py8x_ctx_userdata *) i8x_ctx_get_userdata (ctx);

  Py_DECREF (ud->log_fn);
  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  Py_RETURN_NONE;
}

/* Python binding for i8x_ctx_import_bytecode.  */

static PyObject *
py8x_ctx_import_bytecode (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  Py_buffer buffer;
  const char *srcname;
  long srcoff;

  if (!PyArg_ParseTuple (args, "O"
#if IS_PY3
			 "y"
#else
			 "s"
#endif /* IS_PY3 */
			 "*zl", &ctxc, &buffer, &srcname, &srcoff))
    return NULL;

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_bytecode (ctx,
					   buffer.buf, buffer.len,
					   srcname, srcoff,
					   &func);
  PyBuffer_Release (&buffer);
  PY8X_CHECK_CALL (ctx, err);

  return PyCapsule_New (func, NULL, py8x_ob_unref);
}

/* Implementation function for all native functions we create.  */

static i8x_err_e
py8x_natfunc_impl (struct i8x_xctx *xctx,
		  struct i8x_inf *inf,
		  struct i8x_func *func,
		  union i8x_value *args,
		  union i8x_value *rets)
{
  abort ();
}

/* Userdata cleanup for all native functions we create.  */

static void
py8x_natfunc_udcleanup (void *userdata)
{
  PyObject *impl = (PyObject *) userdata;

  Py_DECREF (impl);
}

/* Python binding for i8x_ctx_import_native.  */

static PyObject *
py8x_ctx_import_native (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  const char *provider, *name, *ptypes, *rtypes;
  PyObject *impl;

  if (!PyArg_ParseTuple (args, "OssssO", &ctxc,
			 &provider, &name, &ptypes, &rtypes, &impl))
    return NULL;

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_native (ctx,
					 provider, name, ptypes, rtypes,
					 py8x_natfunc_impl, &func);
  PY8X_CHECK_CALL (ctx, err);

  Py_INCREF (impl);
  i8x_func_set_userdata (func, impl, py8x_natfunc_udcleanup);

  return PyCapsule_New (func, NULL, py8x_ob_unref);
}

/* Python binding for i8x_ctx_get_funcref.  */

static PyObject *
py8x_ctx_get_funcref (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  const char *provider, *name, *ptypes, *rtypes;

  if (!PyArg_ParseTuple (args, "Ossss", &ctxc,
			 &provider, &name, &ptypes, &rtypes))
    return NULL;

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct i8x_funcref *ref;
  i8x_err_e err = i8x_ctx_get_funcref (ctx,
				       provider, name, ptypes, rtypes,
				       &ref);
  PY8X_CHECK_CALL (ctx, err);

  return PyCapsule_New (ref, NULL, py8x_ob_unref);
}

#pragma libi8x_api_functions

/* Module-level functions table.  */

#define PY8X_FUNCTION(name) {#name, py8x_ ## name, METH_VARARGS, NULL}

static PyMethodDef libi8x_methods[] = {
  PY8X_FUNCTION (ctx_new),
  PY8X_FUNCTION (ctx_set_log_fn),
  PY8X_FUNCTION (ctx_import_bytecode),
  PY8X_FUNCTION (ctx_import_native),
  PY8X_FUNCTION (ctx_get_funcref),
#pragma libi8x_api_function_table
  {NULL, NULL, 0, NULL}
};

/* Module definition.  */

static struct PyModuleDef libi8x_moduledef =
  {
    PyModuleDef_HEAD_INIT,
    .m_name = "_libi8x",
    .m_doc = PyDoc_STR ("Python bindings for libi8x."),
    .m_size = -1,
    .m_methods = libi8x_methods,
  };

/* Module initialization function.  */

#define PY8X_CONSTANT(mod, name) PyModule_AddIntConstant (mod, #name, name)

MODULE_INIT_FUNC (_libi8x)
{
  PyObject *m = PyModule_Create (&libi8x_moduledef);

#pragma libi8x_api_constants

  return m;
}
