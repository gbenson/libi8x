/* Copyright (C) 2017 Red Hat, Inc.
   This file is part of the Infinity Note Execution Library.

   The Infinity Note Execution Library is free software; you can
   redistribute it and/or modify it under the terms of the GNU Lesser
   General Public License as published by the Free Software
   Foundation; either version 2.1 of the License, or (at your option)
   any later version.

   The Infinity Note Execution Library is distributed in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the
   implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.  See the GNU Lesser General Public License for more
   details.

   You should have received a copy of the GNU Lesser General Public
   License along with the Infinity Note Execution Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <py3c.h>
#include <libi8x.h>

#define PY8X_MAX(a, b) ((a) > (b) ? (a) : (b))

#define PY8X_STRINGIZE(x) PY8X_STRINGIZE_1(x)
#define PY8X_STRINGIZE_1(x) #x

#define py8x_not_implemented()						\
  do {									\
    PyErr_SetString (PyExc_NotImplementedError,				\
		     __FILE__ ":" PY8X_STRINGIZE (__LINE__));		\
    return NULL;							\
  } while (0)

/* Exceptions.  */

static PyObject *py8x_Error;

#define PY8X_RAISE(msg)							\
  do {									\
    PyErr_SetString (py8x_Error, msg);					\
    return NULL;							\
  } while (0)

#define PY8X_CHECK_CALL(ctx, err)					\
  do {									\
    if (err == I8X_ENOMEM)						\
      return PyErr_NoMemory ();						\
    else if (err == I8X_NATCALL_FAILED && PyErr_Occurred () != NULL)	\
      return NULL; /* User code raised an exception.  */		\
    else if (err != I8X_OK)						\
      {									\
        char buf[1024];							\
	PY8X_RAISE (i8x_ctx_strerror_r (ctx, err, buf,  sizeof (buf)));	\
      }									\
  } while (0)

/* Helpers for each libi8x object.  */

#define PY8X_OBJECT_FUNCTIONS(TYPE, PREFIX)				\
  static inline struct i8x_ ## TYPE * __attribute__ ((always_inline))	\
  py8x_ ## PREFIX ## _from_capsule (PyObject *c)			\
  {									\
    return (struct i8x_ ## TYPE *) PyCapsule_GetPointer (c, NULL);	\
  }
#pragma libi8x_api_object_functions

/* PyCapsule_Destructor suitable for all libi8x objects.  */

static void
py8x_ob_unref (PyObject *obc)
{
  i8x_ob_unref (py8x_ob_from_capsule (obc));
}

/* Py_DecRef wrapped as i8x_cleanup_fn_t.  */

static void
py8x_py_decref (void *userdata)
{
  PyObject *obj = (PyObject *) userdata;

  Py_DECREF (obj);
}

/* Context (i8x_ctx) userdata.  */

struct py8x_ctx_userdata
{
  /* Logging function.  */
  PyObject *log_fn;
};

/* Free context userdata.  */

static void
py8x_ctx_userdata_free (void *ud_p)
{
  struct py8x_ctx_userdata *ud = (struct py8x_ctx_userdata *) ud_p;

  Py_XDECREF (ud->log_fn);

  free (ud);
}

/* Userdata for the context currently being created by i8x_ctx_new.
   i8x_ctx_new can log before we have a chance to set the context's
   userdata; this static global exists so that py8x_log can access
   the Python log function it needs in this case.  */

static struct py8x_ctx_userdata *py8x_new_context_ud;

/* Logging function set for all i8x_ctx objects we create.  */

static void
py8x_log (struct i8x_ctx *ctx,
	  int pri, const char *file, int line, const char *fn,
	  const char *format, va_list args)
{
  struct py8x_ctx_userdata *ud =
    (struct py8x_ctx_userdata *) i8x_ctx_get_userdata (ctx);
  char *msg;
  int count;
  PyObject *arglist;
  PyObject *result;

  /* No userdata means we're in i8x_ctx_new, before
     py8x_ctx_new has had chance to set it.  */
  if (ud == NULL)
    ud = py8x_new_context_ud;
  if (ud == NULL)
    abort ();

  count = vasprintf (&msg, format, args);
  if (count < 0)
    msg = "vasprintf failed";

  if (ud->log_fn == Py_None)
    {
      /* PySys_WriteStderr wants 1000 bytes max.  */
      char buf[1000];

      snprintf (buf, sizeof (buf), "py8x: %s: %s", fn, msg);
      buf[sizeof (buf) - 1] = '\0';
      PySys_WriteStderr ("%s", buf);
    }
  else
    {
      arglist = Py_BuildValue ("isiss", pri, file, line, fn, msg);

      result = PyEval_CallObject (ud->log_fn, arglist);
      Py_DECREF (arglist);

      Py_DECREF (result);
    }

  if (count >= 0)
    free (msg);
}

/* Python binding for i8x_ctx_new.  */

static PyObject *
py8x_ctx_new (PyObject *self, PyObject *args)
{
  int flags;
  PyObject *log_fn;
  struct i8x_ctx *ctx = NULL;
  i8x_err_e err;

  if (!PyArg_ParseTuple (args, "iO", &flags, &log_fn))
    return NULL;

  py8x_new_context_ud = calloc (1, sizeof (struct py8x_ctx_userdata));
  if (py8x_new_context_ud == NULL)
    return PyErr_NoMemory ();

  Py_INCREF (log_fn);
  py8x_new_context_ud->log_fn = log_fn;

  err = i8x_ctx_new (flags, py8x_log, &ctx);

  if (err == I8X_OK)
    i8x_ctx_set_userdata (ctx, py8x_new_context_ud, py8x_ctx_userdata_free);
  else
    py8x_ctx_userdata_free (py8x_new_context_ud);

  py8x_new_context_ud = NULL;

  PY8X_CHECK_CALL (NULL, err);

  return PyCapsule_New (ctx, NULL, py8x_ob_unref);
}

/* Python binding for i8x_ctx_set_log_fn.  */

static PyObject *
py8x_ctx_set_log_fn (PyObject *self, PyObject *args)
{
  PyObject *ctxc, *log_fn;

  if (!PyArg_ParseTuple (args, "OO", &ctxc, &log_fn))
    return NULL;

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct py8x_ctx_userdata *ud =
    (struct py8x_ctx_userdata *) i8x_ctx_get_userdata (ctx);

  Py_DECREF (ud->log_fn);
  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  Py_RETURN_NONE;
}

/* Function (i8x_func) userdata.  */

struct py8x_func_userdata
{
  /* Referenced parent capsule (for i8x_ob_unref ordering).  */
  PyObject *parent;

  /* Implementation (native only).  */
  PyObject *impl;
};

/* Create function userdata.  */

static struct py8x_func_userdata *
py8x_func_userdata_new (PyObject *parent, PyObject *impl)
{
  struct py8x_func_userdata *ud	\
    = calloc (1, sizeof (struct py8x_func_userdata));

  if (ud != NULL)
    {
      Py_INCREF (parent);
      ud->parent = parent;

      Py_XINCREF (impl);
      ud->impl = impl;
    }

  return ud;
}

/* Free function userdata.  */

static void
py8x_func_userdata_free (void *ud_p)
{
  struct py8x_func_userdata *ud = (struct py8x_func_userdata *) ud_p;

  Py_XDECREF (ud->impl);
  Py_DECREF (ud->parent);

  free (ud);
}

/* Helper for py8x_natfunc_impl.  */

#define PY8X_NFI_SETARG(i, v)						\
  do {									\
    PyObject *arg = v;							\
									\
    if (arg == NULL || PyTuple_SetItem (args, (i), arg) != 0)		\
      {									\
	Py_DECREF (args);						\
	return I8X_NATCALL_FAILED;					\
      }									\
  } while (0)

/* Implementation function for native functions we create.  */

static i8x_err_e
py8x_natfunc_impl (struct i8x_xctx *xctx,
		  struct i8x_inf *inf,
		  struct i8x_func *func,
		  union i8x_value *argv,
		  union i8x_value *retv)
{
  struct i8x_funcref *ref = i8x_func_get_funcref (func);
  size_t argc = i8x_funcref_get_num_params (ref);
  PyObject *args = PyTuple_New (3 + argc);

  if (args == NULL)
    return I8X_NATCALL_FAILED;

  /* Pack the arguments.  */
  PY8X_NFI_SETARG (0, PyCapsule_New (i8x_xctx_ref (xctx), NULL, py8x_ob_unref));
  PY8X_NFI_SETARG (1, PyCapsule_New (i8x_inf_ref (inf), NULL, py8x_ob_unref));
  PY8X_NFI_SETARG (2, PyCapsule_New (i8x_func_ref (func), NULL, py8x_ob_unref));

  struct i8x_list *types;
  struct i8x_listitem *li;
  size_t i;

  types = i8x_funcref_get_ptypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (args);
	  return I8X_NATCALL_FAILED;
	}
      else
	PY8X_NFI_SETARG (3 + i, PyLong_FromLong (argv[i].i));
    }

  /* Make the call.  */
  struct py8x_func_userdata *ud =
    (struct py8x_func_userdata *) i8x_func_get_userdata (func);

  PyObject *rets = PyObject_Call (ud->impl, args, NULL);
  Py_DECREF (args);
  if (rets == NULL)
    return I8X_NATCALL_FAILED;

  /* Unpack the returns.  */
  size_t retc = i8x_funcref_get_num_returns (ref);
  if (PySequence_Length (rets) != retc)
    {
      PyErr_SetString (py8x_Error, "wrong number of returns");

      Py_DECREF (rets);
      return I8X_NATCALL_FAILED;
    }

  types = i8x_funcref_get_rtypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      PyObject *ret = PySequence_GetItem (rets, retc - i - 1);

      if (ret == NULL)
	{
	  Py_DECREF (rets);
	  return I8X_NATCALL_FAILED;
	}

      if (i8x_type_is_functype (type))
	{
	  PyErr_SetString (PyExc_NotImplementedError,
			   __FILE__ ":" PY8X_STRINGIZE (__LINE__));

	  Py_DECREF (ret);
	  Py_DECREF (rets);
	  return I8X_NATCALL_FAILED;
	}
      else
	{
	  long value = PyLong_AsLong (ret);

	  Py_DECREF (ret);
	  if (value == -1 && PyErr_Occurred () != NULL)
	    {
	      Py_DECREF (rets);
	      return I8X_NATCALL_FAILED;
	    }

	  retv[i].i = value;
	}
    }

  Py_DECREF (rets);
  return I8X_OK;
}

/* Python binding for i8x_ctx_import_bytecode.  */

static PyObject *
py8x_ctx_import_bytecode (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  Py_buffer buffer;
  const char *srcname;
  long srcoff;

  if (!PyArg_ParseTuple (args, "O"
#if IS_PY3
			 "y"
#else
			 "s"
#endif /* IS_PY3 */
			 "*zl", &ctxc, &buffer, &srcname, &srcoff))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new (ctxc, NULL);
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_bytecode (ctx,
					   buffer.buf, buffer.len,
					   srcname, srcoff,
					   &func);
  PyBuffer_Release (&buffer);

  if (err == I8X_OK)
    i8x_func_set_userdata (func, ud, py8x_func_userdata_free);
  else
    py8x_func_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return PyCapsule_New (func, NULL, py8x_ob_unref);
}

/* Python binding for i8x_ctx_import_native.  */

static PyObject *
py8x_ctx_import_native (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  const char *provider, *name, *ptypes, *rtypes;
  PyObject *impl;

  if (!PyArg_ParseTuple (args, "OssssO", &ctxc,
			 &provider, &name, &ptypes, &rtypes, &impl))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new (ctxc, impl);
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = py8x_ctx_from_capsule (ctxc);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_native (ctx,
					 provider, name, ptypes, rtypes,
					 py8x_natfunc_impl, &func);
  if (err == I8X_OK)
    i8x_func_set_userdata (func, ud, py8x_func_userdata_free);
  else
    py8x_func_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return PyCapsule_New (func, NULL, py8x_ob_unref);
}

/* Python binding for i8x_xctx_call.  */

static PyObject *
py8x_xctx_call (PyObject *self, PyObject *args)
{
  PyObject *xctxc, *refc, *infc, *tmp;

  if (!PyArg_ParseTuple (args, "OOOO", &xctxc, &refc, &infc, &tmp))
    return NULL;
  args = tmp;

  struct i8x_funcref *ref = py8x_funcref_from_capsule (refc);
  size_t argc = i8x_funcref_get_num_params (ref);
  size_t retc = i8x_funcref_get_num_returns (ref);

  if (PySequence_Length (args) != argc)
    PY8X_RAISE ("wrong number of arguments");

  union i8x_value *argv = alloca (PY8X_MAX (argc, retc));
  union i8x_value *retv = argv;
  struct i8x_list *types;
  struct i8x_listitem *li;
  size_t i;

  types = i8x_funcref_get_ptypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      PyObject *arg = PySequence_GetItem (args, i);

      if (arg == NULL)
	return NULL;

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (arg);
	  py8x_not_implemented ();
	}
      else
	{
	  long value = PyLong_AsLong (arg);

	  Py_DECREF (arg);
	  if (value == -1 && PyErr_Occurred () != NULL)
	    return NULL;

	  argv[i].i = value;
	}
    }

  struct i8x_xctx *xctx = py8x_xctx_from_capsule (xctxc);
  struct i8x_inf *inf = py8x_inf_from_capsule (infc);
  struct i8x_ctx *ctx = i8x_xctx_get_ctx (xctx);
  i8x_err_e err = i8x_xctx_call (xctx, ref, inf, argv, retv);

  PY8X_CHECK_CALL (ctx, err);

  PyObject *result = PyTuple_New (retc);
  if (result == NULL)
    return NULL;

  types = i8x_funcref_get_rtypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (result);
	  py8x_not_implemented ();
	}
      else
	{
	  PyObject *ret = PyLong_FromLong (retv[i].i);

	  if (ret == NULL
	      || PyTuple_SetItem (result, retc - i - 1, ret) != 0)
	    {
	      Py_DECREF (result);
	      return NULL;
	    }
	}
    }

  return result;
}

#pragma libi8x_api_functions

/* Module-level functions table.  */

#define PY8X_FUNCTION(name) {#name, py8x_ ## name, METH_VARARGS, NULL}

static PyMethodDef libi8x_methods[] = {
  PY8X_FUNCTION (ctx_new),
  PY8X_FUNCTION (ctx_set_log_fn),
  PY8X_FUNCTION (ctx_import_bytecode),
  PY8X_FUNCTION (ctx_import_native),
  PY8X_FUNCTION (xctx_call),
#pragma libi8x_api_function_table
  {NULL, NULL, 0, NULL}
};

/* Module definition.  */

static struct PyModuleDef libi8x_moduledef =
  {
    PyModuleDef_HEAD_INIT,
    .m_name = "_libi8x",
    .m_doc = PyDoc_STR ("Python bindings for libi8x."),
    .m_size = -1,
    .m_methods = libi8x_methods,
  };

/* Module initialization function.  */

#define PY8X_CONSTANT(mod, name) PyModule_AddIntConstant (mod, #name, name)

MODULE_INIT_FUNC (_libi8x)
{
  PyObject *m = PyModule_Create (&libi8x_moduledef);
  if (m == NULL)
    return NULL;

  py8x_Error = PyErr_NewException ("_libi8x.Error", PyExc_RuntimeError, NULL);
  if (py8x_Error == NULL)
    return NULL;

  if (PyModule_AddObject (m, "Error", py8x_Error) != 0)
    return NULL;

#pragma libi8x_api_constants

  return m;
}
