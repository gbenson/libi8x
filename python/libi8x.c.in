/* Copyright (C) 2017 Red Hat, Inc.
   This file is part of the Infinity Note Execution Library.

   The Infinity Note Execution Library is free software; you can
   redistribute it and/or modify it under the terms of the GNU Lesser
   General Public License as published by the Free Software
   Foundation; either version 2.1 of the License, or (at your option)
   any later version.

   The Infinity Note Execution Library is distributed in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the
   implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
   PURPOSE.  See the GNU Lesser General Public License for more
   details.

   You should have received a copy of the GNU Lesser General Public
   License along with the Infinity Note Execution Library; if not, see
   <http://www.gnu.org/licenses/>.  */

#include <py3c.h>
#include <libi8x.h>

#define PY8X_MAX(a, b) ((a) > (b) ? (a) : (b))

#define PY8X_STRINGIZE(x) PY8X_STRINGIZE_1(x)
#define PY8X_STRINGIZE_1(x) #x

#define py8x_not_implemented()						\
  do {									\
    PyErr_SetString (PyExc_NotImplementedError,				\
		     __FILE__ ":" PY8X_STRINGIZE (__LINE__));		\
    return NULL;							\
  } while (0)

/* Exceptions.  */

static PyObject *py8x_I8XError;

#define PY8X_RAISE(msg)							\
  do {									\
    PyErr_SetString (py8x_I8XError, msg);				\
    return NULL;							\
  } while (0)

#define PY8X_CHECK_CALL(ctx, err)					\
  do {									\
    if (err == I8X_ENOMEM)						\
      return PyErr_NoMemory ();						\
    else if ((err == I8X_NATCALL_FAILED					\
	      || err == I8X_READ_MEM_FAILED)				\
	     && PyErr_Occurred () != NULL)				\
      return NULL; /* User code raised an exception.  */		\
    else if (err != I8X_OK)						\
      {									\
        char buf[1024];							\
	PY8X_RAISE (i8x_ctx_strerror_r (ctx, err, buf,  sizeof (buf)));	\
      }									\
  } while (0)

/* Attribute name under which py8x_encapsulate* stores libi8x
   object PyCapsules in the Python wrapper objects it creates.  */

#define PY8X_CNAME_ATTR "__i8x_object"

/* Helpers for each libi8x object.  */

#define PY8X_OBJECT_FUNCTIONS(TYPE, PREFIX)				\
  static inline struct i8x_ ## TYPE * __attribute__ ((always_inline))	\
  py8x_ ## PREFIX ## _from_capsule (PyObject *wrapped)			\
  {									\
    PyObject *c = PyObject_GetAttrString (wrapped, PY8X_CNAME_ATTR);	\
    if (c == NULL)							\
      return NULL;							\
    return (struct i8x_ ## TYPE *) PyCapsule_GetPointer (c, NULL);	\
  }
#pragma libi8x_api_object_functions

#define PY8X_FROM_CAPSULE_2(TYPE, NAME)					\
  py8x_ ## TYPE ## _from_capsule (NAME ## c);				\
  if (NAME == NULL)							\
    return NULL

#define PY8X_FROM_CAPSULE(TYPENAME)					\
  PY8X_FROM_CAPSULE_2 (TYPENAME, TYPENAME)

/* PyCapsule_Destructor suitable for all libi8x objects.  */

static void
py8x_ob_unref (PyObject *obc)
{
  i8x_ob_unref (PyCapsule_GetPointer (obc, NULL));
}

/* Userdata for all libi8x objects we create.  May be extended.
   Every libi8x object we pass into Python-space has one of these.
   It can be supplied to py8x_encapsulate* by the object's creator
   (if the object requires extended userdata).  If not supplied a
   generic userdata will be created.  It has two functions:

    1) It contains a regular reference to the parent object's
       Python wrapper.  This ensures parent objects remain live
       while live Python references to their children exist.
       (Python-side references are all child-parent).

    2) It contains a weak reference to this object's Python
       wrapper.  This interning means that Python objects can
       be compared using "is".  */

struct py8x_userdata;

struct py8x_userdata_ops
{
  const char *name;
  size_t size;
  void (*cleanup) (struct py8x_userdata *ud);
};

struct py8x_userdata
{
  const struct py8x_userdata_ops *ops;

  /* PyCapsule of parent object (referenced by us).
     NULL for i8x_ctx objects.  */
  PyObject *parent;

  /* PyWeakref of our own wrapped PyCapsule.  */
  PyObject *selfwr;
};

#define PY8X_USERDATA_FIELDS struct py8x_userdata _oud

/* Generic userdata ops for nonspecialized objects.  */

static const struct py8x_userdata_ops py8x_ob_udops =
  {
    "i8x_object",
    sizeof (struct py8x_userdata),
  };

/* Allocate and initialize a new py8x_userdata.  */

static struct py8x_userdata *
py8x_userdata_new (const struct py8x_userdata_ops *ops)
{
  struct py8x_userdata *ud;

  ud = calloc (1, ops->size);
  if (ud != NULL)
    ud->ops = ops;

  return ud;
}

/* Userdata cleanup for all objects.  */

static void
py8x_userdata_free (void *ud_p)
{
  struct py8x_userdata *ud = (struct py8x_userdata *) ud_p;

  if (ud->ops->cleanup != NULL)
    ud->ops->cleanup (ud);

  Py_XDECREF (ud->parent);
  Py_XDECREF (ud->selfwr);

  free (ud);
}

/* Get an object's userdata.  */

#define py8x_get_userdata(o)						\
  ((struct py8x_userdata *)						\
     i8x_ob_get_userdata ((struct i8x_object *) (o)))

/* Encapsulate and return a libi8x object.  */

static PyObject *py8x_ob_get_wrap_fn (struct i8x_object *ob);

static PyObject *
py8x_encapsulate_2 (struct i8x_object *ob, struct py8x_userdata *new_ud)
{
  struct py8x_userdata *ud = py8x_get_userdata (ob);
  PyObject *result = NULL;

  if (ud != NULL && new_ud != NULL)
    {
      /* The caller supplied userdata for an object that already has
	 userdata set.  This is a programmer error.  */
      PyErr_SetString (PyExc_AssertionError, "ud != NULL && new_ud != NULL");
      return NULL;
    }

  if (ud == NULL)
    {
      /* The object has no userdata. Create if necessary.  */
      ud = new_ud;
      if (ud == NULL)
	ud = py8x_userdata_new (&py8x_ob_udops);
      if (ud == NULL)
	return PyErr_NoMemory ();

      /* Attach it to the object. */
      i8x_ob_set_userdata (ob, ud, py8x_userdata_free);

      /* Reference the object's parent's wrapper.  */
      struct i8x_object *parent = i8x_ob_get_parent (ob);

      if (parent != NULL)
	{
	  ud->parent = py8x_encapsulate_2 (parent, NULL);
	  if (ud->parent == NULL)
	    return NULL;
	}
    }

  /* Try and use a previously-created wrapped capsule.  */
  if (ud->selfwr != NULL)
    {
      result = PyWeakref_GetObject (ud->selfwr);
      if (result == NULL)
	return NULL;

      if (result == Py_None)
	{
	  result = NULL;

	  Py_DECREF (ud->selfwr);
	  ud->selfwr = NULL;
	}
      else
	Py_INCREF (result);
    }

  /* Create a new wrapped capsule if necessary.  */
  if (result == NULL)
    {
      PyObject *capsule;

      /* Create a capsule to hold the object.  */
      capsule = PyCapsule_New (i8x_ob_ref (ob), NULL, py8x_ob_unref);
      if (capsule == NULL)
	return NULL;

      /* Create a Python object to hold the capsule.  */
      result = PyObject_CallFunction (py8x_ob_get_wrap_fn (ob),
				      "s", i8x_ob_get_classname (ob));
      if (result == NULL)
	{
	  Py_DECREF (capsule);
	  return NULL;
	}

      /* Store the capsule in the wrapper object.  */
      int err = PyObject_SetAttrString (result, PY8X_CNAME_ATTR, capsule);
      Py_DECREF (capsule);
      if (err != 0)
	{
	  Py_DECREF (result);
	  return NULL;
	}

      /* Store a weak reference to our own wrapper object.  */
      ud->selfwr = PyWeakref_NewRef (result, NULL);
      if (ud->selfwr == NULL)
	{
	  Py_DECREF (result);
	  return NULL;
	}
    }

  return result;
}

static PyObject *
py8x_encapsulate_1 (struct i8x_object *ob, struct py8x_userdata *ud)
{
  PyObject *result = py8x_encapsulate_2 (ob, ud);

  i8x_ob_unref (ob);

  return result;
}

#define py8x_encapsulate(x)						\
  (py8x_encapsulate_1 ((struct i8x_object *) x, NULL))

/* Helpers for objects with extended userdata.  */

#define PY8X_USERDATA_FUNCTIONS(TYPE)					\
  static inline struct py8x_ ## TYPE ## _userdata *			\
    __attribute__ ((always_inline))					\
  py8x_ ## TYPE ## _userdata_new (void)					\
  {									\
    return (struct py8x_ ## TYPE ## _userdata *)			\
      py8x_userdata_new (&py8x_ ## TYPE ## _udops);			\
  }									\
									\
  static inline struct py8x_ ## TYPE ## _userdata *			\
    __attribute__ ((always_inline))					\
  py8x_ ## TYPE ## _get_userdata (struct i8x_ ## TYPE *x)		\
  {									\
    return (struct py8x_ ## TYPE ## _userdata *)			\
      i8x_ ## TYPE ## _get_userdata (x);				\
  }									\
									\
  static inline PyObject * __attribute__ ((always_inline))		\
  py8x_ ## TYPE ## _encapsulate (struct i8x_ ## TYPE *x,		\
				 struct py8x_ ## TYPE ## _userdata *ud) \
  {									\
    return py8x_encapsulate_1 ((struct i8x_object *) x,			\
			       (struct py8x_userdata *) ud);		\
  }

/* Context (i8x_ctx) userdata.  */

struct py8x_ctx_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Object wrapping function.  */
  PyObject *wrap_fn;

  /* Logging function.  */
  PyObject *log_fn;
};

static void
py8x_ctx_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_ctx_userdata *ud = (struct py8x_ctx_userdata *) ud_p;

  Py_DECREF (ud->wrap_fn);
  Py_DECREF (ud->log_fn);
}

static const struct py8x_userdata_ops py8x_ctx_udops =
  {
    "i8x_ctx",
    sizeof (struct py8x_ctx_userdata),
    py8x_ctx_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (ctx)

static PyObject *
py8x_ob_get_wrap_fn (struct i8x_object *ob)
{
  return py8x_ctx_get_userdata (i8x_ob_get_ctx (ob))->wrap_fn;
}

/* Userdata for the context currently being created by i8x_ctx_new.
   i8x_ctx_new can log before we have a chance to set the context's
   userdata; this static global exists so that py8x_log can access
   the Python log function it needs in this case.  */

static struct py8x_ctx_userdata *py8x_new_context_ud;

/* Logging function for all py8x-created contexts.  */

static void
py8x_log (struct i8x_ctx *ctx,
	  int pri, const char *file, int line, const char *fn,
	  const char *format, va_list args)
{
  struct py8x_ctx_userdata *ud = py8x_ctx_get_userdata (ctx);
  char *msg;
  int count;
  PyObject *result = NULL;

  /* No userdata means we're in i8x_ctx_new, before
     py8x_ctx_new has had chance to set it.  */
  if (ud == NULL)
    ud = py8x_new_context_ud;
  if (ud == NULL)
    abort ();

  count = vasprintf (&msg, format, args);
  if (count < 0)
    msg = "vasprintf failed";

  /* Call the user-defined logging function if there is one.  */
  if (ud->log_fn != Py_None)
    {
      result = PyObject_CallFunction (ud->log_fn, "isiss", pri,
				      file, line, fn, msg);

      /* Note that there's no way to signal an error to libi8x
	 in the event the logging function raises an exception,
	 so exceptions here may appear in place of others.  We
	 write what's happening to stderr to give some kind of
	 clue.  */

      if (result == NULL)
	{
	  PySys_WriteStderr ("py8x: user-defined logger failed with "
			     "the following exception:\n");
	  PyErr_PrintEx (0);
	  PySys_WriteStderr ("py8x: the message being logged was:\n");
	}
    }

  if (result == NULL)
    {
      /* PySys_WriteStderr wants 1000 bytes max.  */
      char buf[1000];

      snprintf (buf, sizeof (buf), "py8x: %s: %s", fn, msg);
      buf[sizeof (buf) - 1] = '\0';
      PySys_WriteStderr ("%s", buf);
    }

  Py_XDECREF (result);

  if (count >= 0)
    free (msg);
}

/* Python binding for i8x_ctx_new.  */

static PyObject *
py8x_ctx_new (PyObject *self, PyObject *args)
{
  PyObject *wrap_fn;
  int flags;
  PyObject *log_fn;
  struct py8x_ctx_userdata *ud;
  struct i8x_ctx *ctx = NULL;
  i8x_err_e err;

  if (!PyArg_ParseTuple (args, "OiO", &wrap_fn, &flags, &log_fn))
    return NULL;

  ud = py8x_ctx_userdata_new ();
  if (ud == NULL)
    return NULL;

  Py_INCREF (wrap_fn);
  ud->wrap_fn = wrap_fn;

  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  py8x_new_context_ud = ud;
  err = i8x_ctx_new (flags, py8x_log, &ctx);
  py8x_new_context_ud = NULL;

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (NULL, err);

  return py8x_ctx_encapsulate (ctx, ud);
}

/* Python binding for i8x_ctx_set_log_fn.  */

static PyObject *
py8x_ctx_set_log_fn (PyObject *self, PyObject *args)
{
  PyObject *ctxc, *log_fn;

  if (!PyArg_ParseTuple (args, "OO", &ctxc, &log_fn))
    return NULL;

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct py8x_ctx_userdata *ud = py8x_ctx_get_userdata (ctx);

  Py_DECREF (ud->log_fn);
  Py_INCREF (log_fn);
  ud->log_fn = log_fn;

  Py_RETURN_NONE;
}

/* Function (i8x_func) userdata.  */

struct py8x_func_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Implementation (native only).  */
  PyObject *impl;
};

static void
py8x_func_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_func_userdata *ud = (struct py8x_func_userdata *) ud_p;

  Py_XDECREF (ud->impl);
}

static const struct py8x_userdata_ops py8x_func_udops =
  {
    "i8x_func",
    sizeof (struct py8x_func_userdata),
    py8x_func_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (func)

/* Helper for py8x_natfunc_impl.  */

#define PY8X_NFI_SETARG(i, v)						\
  do {									\
    PyObject *arg = v;							\
									\
    if (arg == NULL || PyTuple_SetItem (args, (i), arg) != 0)		\
      {									\
	Py_DECREF (args);						\
	return I8X_NATCALL_FAILED;					\
      }									\
  } while (0)

/* Implementation function for all py8x-created native functions.  */

static i8x_err_e
py8x_natfunc_impl (struct i8x_xctx *xctx,
		   struct i8x_inf *inf,
		   struct i8x_func *func,
		   union i8x_value *argv,
		   union i8x_value *retv)
{
  struct i8x_funcref *ref = i8x_func_get_funcref (func);
  size_t argc = i8x_funcref_get_num_params (ref);
  PyObject *args = PyTuple_New (3 + argc);

  if (args == NULL)
    return I8X_NATCALL_FAILED;

  /* Pack the arguments.  */
  PY8X_NFI_SETARG (0, py8x_encapsulate (i8x_xctx_ref (xctx)));
  PY8X_NFI_SETARG (1, py8x_encapsulate (i8x_inf_ref (inf)));
  PY8X_NFI_SETARG (2, py8x_encapsulate (i8x_func_ref (func)));

  struct i8x_list *types;
  struct i8x_listitem *li;
  size_t i;

  types = i8x_funcref_get_ptypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (args);
	  return I8X_NATCALL_FAILED;
	}
      else
	PY8X_NFI_SETARG (3 + i, PyLong_FromLong (argv[i].i));
    }

  /* Make the call.  */
  struct py8x_func_userdata *ud = py8x_func_get_userdata (func);

  PyObject *rets = PyObject_Call (ud->impl, args, NULL);
  Py_DECREF (args);
  if (rets == NULL)
    return I8X_NATCALL_FAILED;

  /* Unpack the returns.  */
  size_t retc = i8x_funcref_get_num_returns (ref);
  if (PySequence_Length (rets) != retc)
    {
      PyErr_SetString (py8x_I8XError, "wrong number of returns");

      Py_DECREF (rets);
      return I8X_NATCALL_FAILED;
    }

  types = i8x_funcref_get_rtypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      PyObject *ret = PySequence_GetItem (rets, retc - i - 1);

      if (ret == NULL)
	{
	  Py_DECREF (rets);
	  return I8X_NATCALL_FAILED;
	}

      if (i8x_type_is_functype (type))
	{
	  PyErr_SetString (PyExc_NotImplementedError,
			   __FILE__ ":" PY8X_STRINGIZE (__LINE__));

	  Py_DECREF (ret);
	  Py_DECREF (rets);
	  return I8X_NATCALL_FAILED;
	}
      else
	{
	  long value = PyLong_AsLong (ret);

	  Py_DECREF (ret);
	  if (value == -1 && PyErr_Occurred () != NULL)
	    {
	      Py_DECREF (rets);
	      return I8X_NATCALL_FAILED;
	    }

	  retv[i].i = value;
	}
    }

  Py_DECREF (rets);
  return I8X_OK;
}

/* Python binding for i8x_ctx_import_bytecode.  */

static PyObject *
py8x_ctx_import_bytecode (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  Py_buffer buffer;
  const char *srcname;
  long srcoff;

  if (!PyArg_ParseTuple (args, "O"
#if IS_PY3
			 "y"
#else
			 "s"
#endif /* IS_PY3 */
			 "*zl", &ctxc, &buffer, &srcname, &srcoff))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_bytecode (ctx,
					   buffer.buf, buffer.len,
					   srcname, srcoff,
					   &func);
  PyBuffer_Release (&buffer);

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return py8x_func_encapsulate (func, ud);
}

/* Python binding for i8x_ctx_import_native.  */

static PyObject *
py8x_ctx_import_native (PyObject *self, PyObject *args)
{
  PyObject *ctxc;
  const char *provider, *name, *ptypes, *rtypes;
  PyObject *impl;

  if (!PyArg_ParseTuple (args, "OssssO", &ctxc,
			 &provider, &name, &ptypes, &rtypes, &impl))
    return NULL;

  struct py8x_func_userdata *ud = py8x_func_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  Py_INCREF (impl);
  ud->impl = impl;

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_func *func;
  i8x_err_e err = i8x_ctx_import_native (ctx,
					 provider, name, ptypes, rtypes,
					 py8x_natfunc_impl, &func);
  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  return py8x_func_encapsulate (func, ud);
}

/* Python binding for i8x_xctx_call.  */

static PyObject *
py8x_xctx_call (PyObject *self, PyObject *args)
{
  PyObject *xctxc, *refc, *infc, *tmp;

  if (!PyArg_ParseTuple (args, "OOOO", &xctxc, &refc, &infc, &tmp))
    return NULL;
  args = tmp;

  struct i8x_funcref *ref = PY8X_FROM_CAPSULE_2 (funcref, ref);
  size_t argc = i8x_funcref_get_num_params (ref);
  size_t retc = i8x_funcref_get_num_returns (ref);

  if (PySequence_Length (args) != argc)
    PY8X_RAISE ("wrong number of arguments");

  union i8x_value *argv = alloca (PY8X_MAX (argc, retc));
  union i8x_value *retv = argv;
  struct i8x_list *types;
  struct i8x_listitem *li;
  size_t i;

  types = i8x_funcref_get_ptypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);
      PyObject *arg = PySequence_GetItem (args, i);

      if (arg == NULL)
	return NULL;

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (arg);
	  py8x_not_implemented ();
	}
      else
	{
	  long value = PyLong_AsLong (arg);

	  Py_DECREF (arg);
	  if (value == -1 && PyErr_Occurred () != NULL)
	    return NULL;

	  argv[i].i = value;
	}
    }

  struct i8x_xctx *xctx = PY8X_FROM_CAPSULE (xctx);
  struct i8x_inf *inf = PY8X_FROM_CAPSULE (inf);
  struct i8x_ctx *ctx = i8x_xctx_get_ctx (xctx);
  i8x_err_e err = i8x_xctx_call (xctx, ref, inf, argv, retv);

  PY8X_CHECK_CALL (ctx, err);

  PyObject *result = PyTuple_New (retc);
  if (result == NULL)
    return NULL;

  types = i8x_funcref_get_rtypes (ref);
  i8x_list_foreach_indexed (types, li, i)
    {
      struct i8x_type *type = i8x_listitem_get_type (li);

      if (i8x_type_is_functype (type))
	{
	  Py_DECREF (result);
	  py8x_not_implemented ();
	}
      else
	{
	  PyObject *ret = PyLong_FromLong (retv[i].i);

	  if (ret == NULL
	      || PyTuple_SetItem (result, retc - i - 1, ret) != 0)
	    {
	      Py_DECREF (result);
	      return NULL;
	    }
	}
    }

  return result;
}

/* Inferior (i8x_inf) userdata.  */

struct py8x_inf_userdata
{
  PY8X_USERDATA_FIELDS;

  /* Memory reader function.  */
  PyObject *read_mem_fn;
};

static void
py8x_inf_userdata_cleanup (struct py8x_userdata *ud_p)
{
  struct py8x_inf_userdata *ud = (struct py8x_inf_userdata *) ud_p;

  Py_XDECREF (ud->read_mem_fn);
}

static const struct py8x_userdata_ops py8x_inf_udops =
  {
    "i8x_inf",
    sizeof (struct py8x_inf_userdata),
    py8x_inf_userdata_cleanup,
  };

PY8X_USERDATA_FUNCTIONS (inf)

/* Helper for py8x_read_mem_fn.  */

#define PY8X_RMF_SETARG(i, v)						\
  do {									\
    PyObject *arg = v;							\
									\
    if (arg == NULL || PyTuple_SetItem (args, (i), arg) != 0)		\
      {									\
	Py_DECREF (args);						\
	return I8X_READ_MEM_FAILED;					\
      }									\
  } while (0)

/* Memory reader function for all py8x-created inferiors.  */

static i8x_err_e
py8x_read_mem_fn (struct i8x_inf *inf, uintptr_t addr, size_t len,
		  void *result)
{
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  if (ud->read_mem_fn == NULL || ud->read_mem_fn == Py_None)
    {
      PyErr_SetString (py8x_I8XError, "inferior has no read_mem function");
      return I8X_READ_MEM_FAILED;
    }

  /* Pack the arguments.  */
  PyObject *args = PyTuple_New (3);
  if (args == NULL)
    return I8X_READ_MEM_FAILED;

  PY8X_RMF_SETARG (0, py8x_encapsulate (i8x_inf_ref (inf)));
  PY8X_RMF_SETARG (1, PyLong_FromUnsignedLong (addr));
  PY8X_RMF_SETARG (2, PyLong_FromSize_t (len));

  /* Make the call.  */
  PyObject *ret = PyObject_Call (ud->read_mem_fn, args, NULL);
  Py_DECREF (args);
  if (ret == NULL)
    return I8X_READ_MEM_FAILED;

  /* Read out the result.  */
  Py_buffer buf;

  if (PyObject_GetBuffer (ret, &buf, PyBUF_SIMPLE) != 0)
    {
      Py_DECREF (ret);
      return I8X_READ_MEM_FAILED;
    }

  if (buf.len != len)
    {
      Py_DECREF (ret);
      PyErr_SetString (py8x_I8XError, "read_mem_fn returned bad length");
      return I8X_READ_MEM_FAILED;
    }

  memcpy (result, buf.buf, len);
  return I8X_OK;
}

/* Python binding for i8x_inf_new.  */

static PyObject *
py8x_inf_new (PyObject *self, PyObject *args)
{
  PyObject *ctxc;

  if (!PyArg_ParseTuple (args, "O", &ctxc))
    return NULL;

  struct py8x_inf_userdata *ud = py8x_inf_userdata_new ();
  if (ud == NULL)
    return PyErr_NoMemory ();

  struct i8x_ctx *ctx = PY8X_FROM_CAPSULE (ctx);
  struct i8x_inf *inf;
  i8x_err_e err = i8x_inf_new (ctx, &inf);

  if (err != I8X_OK)
    py8x_userdata_free (ud);

  PY8X_CHECK_CALL (ctx, err);

  i8x_inf_set_read_mem_fn (inf, py8x_read_mem_fn);

  return py8x_inf_encapsulate (inf, ud);
}

/* Python binding for i8x_ctx_set_read_mem_fn.  */

static PyObject *
py8x_inf_set_read_mem_fn (PyObject *self, PyObject *args)
{
  PyObject *infc, *read_mem_fn;

  if (!PyArg_ParseTuple (args, "OO", &infc, &read_mem_fn))
    return NULL;

  struct i8x_inf *inf = PY8X_FROM_CAPSULE (inf);
  struct py8x_inf_userdata *ud = py8x_inf_get_userdata (inf);

  Py_XDECREF (ud->read_mem_fn);
  Py_INCREF (read_mem_fn);
  ud->read_mem_fn = read_mem_fn;

  Py_RETURN_NONE;
}

/* Helper for methods that return list items (i8x_listitem).  */

#define PY8X_RETURN_LISTITEM(value)					\
  do {									\
    struct i8x_listitem *result = value;				\
									\
    if (result == NULL)							\
      {									\
	PyErr_SetNone(PyExc_StopIteration);				\
	return NULL;							\
      }									\
									\
    return py8x_encapsulate (i8x_listitem_ref (result));		\
  } while (0)

/* Python binding for i8x_list_get_first.  */

static PyObject *
py8x_list_get_first (PyObject *self, PyObject *args)
{
  PyObject *listc;

  if (!PyArg_ParseTuple (args, "O", &listc))
    return NULL;

  struct i8x_list *list = PY8X_FROM_CAPSULE (list);

  PY8X_RETURN_LISTITEM (i8x_list_get_first (list));
}

/* Python binding for i8x_list_get_next.  */

static PyObject *
py8x_list_get_next (PyObject *self, PyObject *args)
{
  PyObject *listc;
  PyObject *currc;

  if (!PyArg_ParseTuple (args, "OO", &listc, &currc))
    return NULL;

  struct i8x_list *list = PY8X_FROM_CAPSULE (list);
  struct i8x_listitem *curr = PY8X_FROM_CAPSULE_2 (listitem, curr);

  PY8X_RETURN_LISTITEM (i8x_list_get_next (list, curr));
}

#pragma libi8x_api_functions

/* Module-level functions table.  */

#define PY8X_FUNCTION(name) {#name, py8x_ ## name, METH_VARARGS, NULL}

static PyMethodDef libi8x_methods[] = {
  PY8X_FUNCTION (ctx_new),
  PY8X_FUNCTION (ctx_set_log_fn),
  PY8X_FUNCTION (ctx_import_bytecode),
  PY8X_FUNCTION (ctx_import_native),
  PY8X_FUNCTION (xctx_call),
  PY8X_FUNCTION (inf_new),
  PY8X_FUNCTION (inf_set_read_mem_fn),
  PY8X_FUNCTION (list_get_first),
  PY8X_FUNCTION (list_get_next),
#pragma libi8x_api_function_table
  {NULL, NULL, 0, NULL}
};

/* Module definition.  */

static struct PyModuleDef libi8x_moduledef =
  {
    PyModuleDef_HEAD_INIT,
    .m_name = "_libi8x",
    .m_doc = PyDoc_STR ("Python bindings for libi8x."),
    .m_size = -1,
    .m_methods = libi8x_methods,
  };

/* Module initialization function.  */

#define PY8X_CONSTANT(mod, name) PyModule_AddIntConstant (mod, #name, name)

MODULE_INIT_FUNC (_libi8x)
{
  PyObject *m = PyModule_Create (&libi8x_moduledef);
  if (m == NULL)
    return NULL;

  py8x_I8XError = PyErr_NewException ("_libi8x.I8XError",
				   PyExc_RuntimeError, NULL);
  if (py8x_I8XError == NULL)
    return NULL;

  if (PyModule_AddObject (m, "I8XError", py8x_I8XError) != 0)
    return NULL;

#pragma libi8x_api_constants

  return m;
}
