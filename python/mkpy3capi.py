#!/usr/bin/env python
# Copyright (C) 2017 Red Hat, Inc.
# This file is part of the Infinity Note Execution Library.
#
# The Infinity Note Execution Library is free software; you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software
# Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# The Infinity Note Execution Library is distributed in the hope
# that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with the Infinity Note Execution Library; if not,
# see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import os
import pycparser
import sys
import subprocess

class API(object):
    def __init__(self, header, include_path):
        with open(header) as fp:
            src = fp.read()
        self.__constants = {}
        self.__extract_cpp_constants(src)
        self.__types = {}
        self.__extract_everything_else(src, include_path)

    def add_constant(self, name):
        assert name not in self.__constants
        self.__constants[name] = True

    def emit_constants(self, fp):
        for name in sorted(self.__constants):
            print('  PY8X_CONSTANT (m, %s);' % name, file=fp)

    def add_type(self, name):
        self.__types[name] = True

    TYPE_PREFIXES = {"object": "ob", "readbuf": "rb"}

    def emit_object_functions(self, fp):
        for name in sorted(self.__types):
            print("PY8X_OBJECT_FUNCTIONS (%s, %s);"
                  % (name, self.TYPE_PREFIXES.get(name, name)),
                  file=fp)

    def add_function(self, name):
        pass

    def emit_functions(self, fp):
        pass

    def __parse_pragma(self, line, prefix="libi8x_api_"):
        if line.startswith("#"):
            line = line[1:].strip().split()
            if (len(line) == 2
                  and line[0] == "pragma"
                  and line[1].startswith(prefix)):
                return line[1][len(prefix):]

    def __emit_boilerplate(self, template, output, fp):
        print("/* %s generated by %s from %s. */"
              % (os.path.basename(output),
                 os.path.basename(sys.argv[0]),
                 os.path.basename(template)), file=fp)
        print("/* DO NOT EDIT THIS FILE, "
              + "EDIT THE TEMPLATE AND REGENERATE. */", file=fp)
        print(file=fp)

    def emit(self, template, output):
        with open(template) as ifp:
            with open(output, "w") as ofp:
                self.__emit_boilerplate(template, output, ofp)
                for line in ifp.readlines():
                    what = self.__parse_pragma(line)
                    if what is None:
                        ofp.write(line)
                    else:
                        getattr(self, "emit_" + what)(ofp)

    def __gcc(self, args, input):
        gcc = subprocess.Popen(("gcc",) + args + ("-",),
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE)
        output, check = gcc.communicate(input.encode("utf-8"))
        assert check is None
        if gcc.returncode != 0:
            sys.exit(1)
        return output.decode("utf-8")

    def __strip_comments(self, src):
        return self.__gcc(("-E", "-fpreprocessed", "-dD"), src)

    def __extract_cpp_constants(self, src):
        """Extract #define constants lost in preprocessing."""
        for line in self.__strip_comments(src).split("\n"):
            if not line.startswith("#"):
                continue
            line = line.split()
            if (len(line) == 3
                  and line[0] == "#define"
                  and "(" not in line[1]):
                self.add_constant(line[1])

    def __parse(self, src, include_path):
        src = src.replace("__attribute__ ((always_inline))", "")
        src = self.__gcc(("-E", "-I" + include_path), src)
        return pycparser.CParser().parse(src)

    def __extract_everything_else(self, src, include_path):
        ASTVisitor(self).visit(self.__parse(src, include_path))

class NodeVisitor(pycparser.c_ast.NodeVisitor):
    def __init__(self, api):
        self.api = api

class ASTVisitor(NodeVisitor):
    def visit_Struct(self, node, PREFIX="i8x_"):
        if node.name.startswith(PREFIX):
            self.api.add_type(node.name[len(PREFIX):])

    def visit_Enum(self, node):
        for enumerator in node.values.enumerators:
            self.api.add_constant(enumerator.name)

    def visit_Decl(self, node):
        name = node.name
        if name is None:
            self.generic_visit(node)
            return

        dv = DeclVisitor(self.api)
        dv.visit(node)
        if dv.is_function:
            assert name.startswith("i8x_")
            if not (name.startswith("i8x_ob_")
                    or name.endswith("_ref")
                    or name.endswith("_unref")
                    or name.find("_new") != -1
                    or name.startswith("i8x_ctx_import_")
                    or name in ("i8x_listitem_get_object",
                                "i8x_ctx_strerror_r",
                                "i8x_ctx_set_log_fn")):
                self.api.add_function(name)

class DeclVisitor(NodeVisitor):
    def visit_Decl(self, node):
        self.is_function = False
        self.generic_visit(node)

    def visit_FuncDecl(self, node):
        assert not self.is_function
        self.is_function = True
        #self.generic_visit(node)

def main():
    if len(sys.argv) != 2:
        print("""\
usage: %s FAKE_INCLUDE_PATH

The pycparser source contains some "fake" standard include files,
but these aren't in the packages pip installs (and the license
may not allow them to be bundled here) so you'll need to
  git clone https://github.com/eliben/pycparser.git
and supply /path/to/pycparser/utils/fake_libc_include as the
argument to this script.""" % sys.argv[0], file=sys.stderr)
        sys.exit(1)
    fake_include_path = sys.argv[1]

    curdir = os.path.dirname(os.path.realpath(sys.argv[0]))
    topdir = os.path.dirname(curdir)
    header = os.path.join(topdir, "libi8x", "libi8x.h")
    output = os.path.join(curdir, "libi8x.c")
    template = output + ".in"

    API(header, fake_include_path).emit(template, output)

if __name__ == "__main__":
    main()
