#!/usr/bin/env python
# Copyright (C) 2017 Red Hat, Inc.
# This file is part of the Infinity Note Execution Library.
#
# The Infinity Note Execution Library is free software; you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software
# Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# The Infinity Note Execution Library is distributed in the hope
# that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with the Infinity Note Execution Library; if not,
# see <http://www.gnu.org/licenses/>.

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import os
import pycparser
import sys
import subprocess

class API(object):
    def __init__(self, header, include_path):
        with open(header) as fp:
            src = fp.read()
        self.__constants = {}
        self.__extract_cpp_constants(src)
        self.__types = {}
        self.__functions = {}
        self.__extract_everything_else(src, include_path)

    def add_constant(self, name):
        assert name not in self.__constants
        self.__constants[name] = True

    def emit_constants(self, fp):
        for name in sorted(self.__constants):
            print('  PY8X_CONSTANT (m, %s);' % name, file=fp)

    def add_type(self, name):
        self.__types[name] = True

    TYPE_PREFIXES = {"object": "ob", "readbuf": "rb"}

    def emit_object_functions(self, fp):
        for name in sorted(self.__types):
            print("PY8X_OBJECT_FUNCTIONS (%s, %s);"
                  % (name, self.TYPE_PREFIXES.get(name, name)),
                  file=fp)

    def add_function(self, type, name, params):
        assert name not in self.__functions
        self.__functions[name] = (type, params)

    def emit_functions(self, fp):
        for name, type_and_params in sorted(self.__functions.items()):
            self.__emit_function(fp, name, *type_and_params)

    def __emit_function(self, fp, name, type, params):
        print("%s: %s, %s" % (name, repr(type), params))
        # XXX print traffic-light of tested or no

    def __parse_pragma(self, line, prefix="libi8x_api_"):
        if line.startswith("#"):
            line = line[1:].strip().split()
            if (len(line) == 2
                  and line[0] == "pragma"
                  and line[1].startswith(prefix)):
                return line[1][len(prefix):]

    def __emit_boilerplate(self, template, output, fp):
        print("/* %s generated by %s from %s. */"
              % (os.path.basename(output),
                 os.path.basename(sys.argv[0]),
                 os.path.basename(template)), file=fp)
        print("/* DO NOT EDIT THIS FILE, "
              + "EDIT THE TEMPLATE AND REGENERATE. */", file=fp)
        print(file=fp)

    def emit(self, template, output):
        with open(template) as ifp:
            with open(output, "w") as ofp:
                self.__emit_boilerplate(template, output, ofp)
                for line in ifp.readlines():
                    what = self.__parse_pragma(line)
                    if what is None:
                        ofp.write(line)
                    else:
                        getattr(self, "emit_" + what)(ofp)

    def __gcc(self, args, input):
        gcc = subprocess.Popen(("gcc",) + args + ("-",),
                               stdin=subprocess.PIPE,
                               stdout=subprocess.PIPE)
        output, check = gcc.communicate(input.encode("utf-8"))
        assert check is None
        if gcc.returncode != 0:
            sys.exit(1)
        return output.decode("utf-8")

    def __strip_comments(self, src):
        return self.__gcc(("-E", "-fpreprocessed", "-dD"), src)

    def __extract_cpp_constants(self, src):
        """Extract #define constants lost in preprocessing."""
        for line in self.__strip_comments(src).split("\n"):
            if not line.startswith("#"):
                continue
            line = line.split()
            if (len(line) == 3
                  and line[0] == "#define"
                  and "(" not in line[1]):
                self.add_constant(line[1])

    def __parse(self, src, include_path):
        src = src.replace("__attribute__ ((always_inline))", "")
        src = self.__gcc(("-E", "-I" + include_path), src)
        return pycparser.CParser().parse(src)

    def __extract_everything_else(self, src, include_path):
        ASTVisitor(self).visit(self.__parse(src, include_path))

class ASTVisitor(pycparser.c_ast.NodeVisitor):
    def __init__(self, api):
        self.api = api

    def visit_Enum(self, node):
        for enumerator in node.values.enumerators:
            self.api.add_constant(enumerator.name)

    def visit_Decl(self, node):
        name = node.name
        if (name is None
            or (name.startswith("i8x_")
                and not (name.startswith("i8x_ob_")
                         or name.endswith("_ref")
                         or name.endswith("_unref")
                         or name.endswith("_userdata")
                         or name.find("_new") != -1
                         or name.startswith("i8x_ctx_import_")
                         or name in ("i8x_ctx_get_funcref",
                                     "i8x_ctx_set_log_fn",
                                     "i8x_ctx_strerror_r",
                                     "i8x_listitem_get_object",
                                     "i8x_note_get_unique_chunk",
                                     "i8x_rb_read_bytes",
                                     "i8x_rb_read_offset_string")))):
            TopLevelDeclVisitor(self.api).visit(node.type)

class TopLevelDeclVisitor(pycparser.c_ast.NodeVisitor):
    def __init__(self, api):
        self.api = api

    def visit_Struct(self, node, PREFIX="i8x_"):
        if node.name.startswith(PREFIX):
            self.api.add_type(node.name[len(PREFIX):])

    def visit_FuncDecl(self, node):
        plv = ParamListVisitor()
        plv.visit(node.args)
        tv = TypeVisitor()
        tv.visit(node.type)
        self.api.add_function(tv.type, tv.name, plv.params)

class ParamListVisitor(pycparser.c_ast.NodeVisitor):
    def visit_ParamList(self, node):
        assert not hasattr(self, "params")
        self.params = []
        for param in node.params:
            self.visit(param)

    def visit_Decl(self, node):
        tv = TypeVisitor()
        tv.visit(node.type)
        self.params.append((tv.type, tv.name))

class TypeVisitor(pycparser.c_ast.NodeVisitor):
    def __init__(self):
        self.__is_const = False
        self.__nonatomic = None # struct or union
        self.__basetype = None
        self.__is_pointer = False
        self.name = None

    @property
    def type(self):
        result = []
        if self.__is_const:
            result.append("const")
        if self.__nonatomic is not None:
            result.append(self.__nonatomic)
        assert self.__basetype is not None
        result.append(self.__basetype)
        if self.__is_pointer:
            result.append("*")
        return " ".join(result)

    def generic_visit(self, node):
        node.show()
        print(dir(node))
        raise NotImplementedError

    def visit_PtrDecl(self, node):
        assert not self.__is_pointer
        self.__is_pointer = True
        assert not node.quals
        self.visit(node.type)

    def visit_TypeDecl(self, node):
        assert self.name is None
        self.name = node.declname
        assert self.name is not None
        if len(node.quals) == 1:
            assert node.quals[0] == "const"
            assert not self.__is_const
            self.__is_const = True
        else:
            assert not node.quals
        self.visit(node.type)

    def visit_IdentifierType(self, node):
        assert self.__nonatomic is None
        assert self.__basetype is None
        assert len(node.names) == 1
        [self.__basetype] = node.names
        assert self.__basetype is not None

    def visit_Struct(self, node):
        self.__visit_Struct_or_Union(node, "struct")

    def visit_Union(self, node):
        self.__visit_Struct_or_Union(node, "union")

    def __visit_Struct_or_Union(self, node, type):
        assert self.__nonatomic is None
        assert self.__basetype is None
        assert node.decls is None
        self.__basetype = node.name
        assert self.__basetype is not None
        self.__nonatomic = type

def main():
    if len(sys.argv) != 2:
        print("""\
usage: %s FAKE_INCLUDE_PATH

The pycparser source contains some "fake" standard include files,
but these aren't in the packages pip installs (and the license
may not allow them to be bundled here) so you'll need to
  git clone https://github.com/eliben/pycparser.git
and supply /path/to/pycparser/utils/fake_libc_include as the
argument to this script.""" % sys.argv[0], file=sys.stderr)
        sys.exit(1)
    fake_include_path = sys.argv[1]

    curdir = os.path.dirname(os.path.realpath(sys.argv[0]))
    topdir = os.path.dirname(curdir)
    header = os.path.join(topdir, "libi8x", "libi8x.h")
    output = os.path.join(curdir, "libi8x.c")
    template = output + ".in"

    API(header, fake_include_path).emit(template, output)

if __name__ == "__main__":
    main()
